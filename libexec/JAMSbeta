#!/usr/bin/env Rscript
suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library(futile.logger))

#####################################
# Define System-specific Functions ##
#####################################
if ((.Platform$OS.type) != "unix"){
    stop("JAMS only works on UNIX. Install Linux and try again.")
}

#Get slurm job ID
slurmjobid <- as.character(Sys.getenv("SLURM_JOB_ID"))

#Decide which kind of system you are on.
if(nchar(slurmjobid) < 3){
    cat("You are not on a Slurm Workload Cluster\n")
} else {
    cat(paste("You are on a Slurm Workload Manager Cluster under jobID", slurmjobid, "\n"))
}

#################
## Get options ##
#################

option_list <- list(
    make_option(c("-p", "--projectname"),
                action="store", default = "MyProject",
                type="character",
                help="Name of project to be used as prefix for output files (required)"),

    make_option(c("-o", "--outdir"),
                action="store", default = getwd(),
                type="character",
                help ="path to where you want the output."),

    make_option(c("-x", "--excel_metadata"),
                action="store", default = NULL,
                type="character",
                help="Metadata file in Excel format, with sheet_1 for phenotable and sheet_2 for phenolabels"),

    make_option(c("-t", "--phenotable"),
                action="store", default = NULL,
                type="character",
                help="Metadata file in tsv format, with headers"),

    make_option(c("-l", "--phenolabels"),
                action="store", default = NULL,
                type="character",
                help="Phenolabels file in tsv format, describing metadata file headers"),

    make_option(c("-c", "--maxnumclasses"),
                action="store", default = 15,
                type="numeric",
                help="Maximum number of classes for a discrete variable to be kept. Default=10"),

    make_option(c("-y", "--jamsfiles_path"),
                action="store", default = NULL,
                type="character",
                help ="path to where all .jams files are"),

    make_option(c("-g", "--minGbNAHS"),
                action="store", default = 0,
                type="numeric",
                help ="If using reads, what is the minimum amount of usable data, in Gbp, for a sample to be included in an experiment. (Default=0)"),

    make_option(c("-a", "--minPctAssembly"),
                action="store", default = 0,
                type="numeric",
                help ="If using reads, what is the minimum percentage assembly into contigs for a sample to be included in an experiment. (Default=0)"),

    make_option(c("-e", "--export_tables"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Export relative abundance tables and feature data tables in tsv format."),

    make_option(c("-d", "--ordination"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate ordination plots."),

    make_option(c("-f", "--make_exploratory_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Relative Abundace heatmaps and spreadsheets based on variance analysis."),

    make_option(c("-k", "--make_comparative_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Relative Abundace heatmaps and spreadsheets for hypothesis testing using metadata categories."),

    make_option(c("-b", "--make_PA_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Relative Abundace heatmaps and spreadsheets for hypothesis testing using metadata categories."),

    make_option(c("-z", "--make_alpha_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate alpha diversity plots."),

    make_option(c("-w", "--load_workspace"),
                action="store", default = NULL,
                type="character",
                help ="/path/to/.RData  -  Continue or change the JAMSbeta pipeline from a previous workspace with an .RData file"),

    make_option(c("-v", "--version"),
                action="store_true", help = "report version")
 )

# get the cmd line options to the script
args <- commandArgs(trailingOnly = TRUE)

# parse the options
opt <- parse_args(OptionParser(option_list = option_list), args)

#Add version from package to opt
opt$verstr <- paste0("JAMS v", packageVersion("JAMS"))

# print version & exit if -v
if (!is.null(opt$version)) {
    print(opt$verstr)
    quit()
}

#Fix path relativity
fixrelpath <- function(JAMSpath = NULL){
    require(R.utils)
    if(!(isAbsolutePath(JAMSpath))){
        fixedpath <- getAbsolutePath(JAMSpath)
    } else {
        fixedpath <- JAMSpath
    }

    return(fixedpath)
}

for (pathtofix in c("outdir", "excel_metadata", "phenotable", "phenolabels", "jamsfiles_path", "load_workspace")){
    if (!is.null(opt[[pathtofix]])){
        opt[[pathtofix]] <- fixrelpath(opt[[pathtofix]])
    }
}

# Determine output directory
if (!is.null(opt$outdir)) {
    setwd(opt$outdir)
} else {
    opt$outdir <- getwd()
}
flog.info(paste("Content will be output to", opt$outdir))

# give help if needed input option not provided
if (all(c((is.null(opt$load_workspace)), (is.null(opt$jamsfiles_path))))) {
    parse_args(OptionParser(option_list = option_list), c("-h"))
    stop("You must supply .jams files with the -y option to build experiments. If you want to use a previous R session image, use --load_workspace")
} else {
    if (!is.null(opt$load_workspace)){
        flog.info("Attempting to continue from a previous JAMSbeta R session.")
        #Decide if workspace supplied is a folder or an image file itself.
        if(file.info(as.character(opt$load_workspace))$isdir == TRUE){
            opt$load_workspace <- file.path(opt$load_workspace, ".RData")
        }
        if (file.exists(opt$load_workspace)) {
            projimagesize <- file.size(opt$load_workspace)
            flog.info(paste("Found previous R session file with", projimagesize, "bytes at", as.character(opt$load_workspace)))
            saveRDS(opt, file = "preloadopt.rds") #Save current options, or else it will be substituted when loading workspace image.
            flog.info("Loading saved workspace image. Please be patient...")
            load(opt$load_workspace)
            preloadopt <- readRDS("preloadopt.rds")
            #Replace old options with new ones
            opt$replaced <- NULL
            optstosub <- names(preloadopt)[!(names(preloadopt) %in% c("jamsfiles_path", "load_workspace", "projimage", "projimagesize"))]
            optstoreset <- c("excel_metadata", "make_alpha_reports", "make_PA_reports", "make_comparative_reports", "make_exploratory_reports", "ordination", "export_tables")[(!(c("excel_metadata", "make_alpha_reports", "make_PA_reports", "make_comparative_reports", "make_exploratory_reports", "ordination", "export_tables") %in% opt$replaced))]
            for (resetopt in optstoreset){
                #flog.info(paste("Option", resetopt, "is set to FALSE."))
                opt[[resetopt]] <- FALSE
            }
            for (nametosub in optstosub){
                if (opt[[nametosub]] != preloadopt[[nametosub]]){
                    flog.info(paste0("For ", nametosub, ", ", opt[[nametosub]], " has been replaced with ", preloadopt[[nametosub]]))
                    opt[[nametosub]] <- preloadopt[[nametosub]]
                    opt$replaced <- append(opt$replaced, nametosub)
                }
            }
            file.remove("preloadopt.rds")
        } else {
            parse_args(OptionParser(option_list = option_list), c("-h"))
            stop("Unable to find a previous R session file in the output folder. If you want to build experiments from scratch, do not use the --continue (-u) option.")
        }
    }
}

#Set defaults
asPA <- FALSE
maxclass <- as.numeric(opt$maxnumclasses)
opt$projimage <- file.path(opt$outdir, ".RData")
###################
## Start project ##
###################
suppressPackageStartupMessages(library(JAMS))
################################
## Define extra functions now ##
## They may be missing due to ##
##  workspace being reloaded  ##
################################
detectHardwareResources <- function(){
    #First off, detect if on Slurm type cluster
    #Get slurm job ID
    currslurmjobid <- as.character(Sys.getenv("SLURM_JOB_ID"))

    if(nchar(currslurmjobid) < 3){
       #Define appropriate functions for non-slurm system
       detectBatchCPUs <- function() {
            ncores <- detectCores()
            if (is.na(ncores)) {
                stop("Could not determine how many CPUs you have. Aborting.")
            }
            return(ncores)
        }

        detectAvailRAM <- function(){
            totmembytes<-as.numeric(get_ram())

            return(totmembytes)
        }

    } else {
        #Define appropriate functions for slurm system
        detectBatchCPUs <- function() {
            jobinforaw <- system2("sacct", args = c("-j", currslurmjobid, "-X"), stdout = TRUE)[3]
            jobinfo <- unlist(strsplit(jobinforaw, split=" "))[which(unlist(strsplit(jobinforaw, split=" ")) != "")]
            ncores <- as.integer(jobinfo[5])
            if (is.na(ncores)) {
                stop("Could not determine how many CPUs you have. Aborting.")
            }
            return(ncores)
        }

        detectAvailRAM <- function(){
            mempercpu <- as.integer(Sys.getenv("SLURM_MEM_PER_CPU"))
            mempernode <- as.integer(Sys.getenv("SLURM_MEM_PER_NODE"))
            cpuspertask <- as.integer(Sys.getenv("SLURM_CPUS_PER_TASK"))

            if(!(is.na(mempernode))){
                totmem <- mempernode
            } else {
                totmem <- mempercpu * cpuspertask
            }

            totmembytes <- totmem * 1000000

            return(totmembytes)
        }
    }
    hardwareRes <- NULL
    hardwareRes[1] <- detectBatchCPUs()
    hardwareRes[2] <- detectAvailRAM()
    names(hardwareRes) <- c("threads", "memory")

    return(hardwareRes)
}

whoopsieplot <- function(msg = "trying to do this."){
    flog.info(paste("Whoops, something went wrong while", msg))
    dev.off()
}

exporttabletsv <- function(dataobj = NULL, project = NULL, basename = NULL, row.names = TRUE, col.names = TRUE, path = NULL){
    flname <- paste(paste("JAMS", project, basename, sep = "_"), "tsv", sep = ".")
    if (!is.null(path)){
        flname <- paste(path, flname, sep = "/")
    }
    write.table(dataobj, file = flname, quote = FALSE, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = row.names, col.names = col.names)
}

flog.info("JAMSbeta start. Gathering information...")
project <- as.character(opt$projectname)
flog.info(paste("Using", project, "for name of project"))

opt$threads <- as.numeric(detectHardwareResources()["threads"])
flog.info(paste("You have", opt$threads, "CPUs available."))

##################
## Get metadata ##
##################

#keep metadata if it has changed from a previous version.
if (!is.null(opt$replaced)){
    if (!("excel_metadata" %in% opt$replaced)){
        opt$excel_metadata <- NULL
    }
    if (!("phenotable" %in% opt$replaced)){
        opt$phenotable <- NULL
        opt$phenolabels <- NULL
    }
}

#Get metadata
if (!(is.null(opt$excel_metadata))) {
    metadataXL <- opt$excel_metadata
    #Get metadata from XL file
    flog.info(paste("Using", metadataXL, "Excel format file to obtain metadata."))
    metadata <- load_metadata_from_xl(xlsxFile = metadataXL)
    phenotable <- metadata[[1]]
    phenolabels <- metadata[[2]]
} else {
    #Metadata not in XL, so get from tsv
    if (!(is.null(opt$phenotable))){
        phenotable <- read.table(file = opt$phenotable, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
    }
    if (!(is.null(opt$phenolabels))){
        phenolabels <- read.table(file = opt$phenolabels, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
    }
}

#Stop if something went wrong
if (!(exists("phenotable")) || (nrow(phenotable) < 1)){
    stop("No data found in the metadata file supplied. Please check file.")
} else {
    flog.info(paste("Metadata has", ncol(phenotable), "columns."))
}

#Check for and eliminate duplicates
Dupes <- phenotable$Sample[duplicated(phenotable$Sample)]
if (length(Dupes) > 0){
    phenotable <- subset(phenotable, !(Sample %in% Dupes))
    flog.warn(paste("There are duplicated sample prefixes in the metadata. Samples", paste0(Dupes, collapse = ", "), "have been excluded from metadata. Will continue with building experiments. If you still want these samples, fix metadata and relaunch JAMSbeta."))
}

##########
## Will keep this running in all cases. Not sure of the consequences for when loading a workspace and NOT changing metadata.
opt$metadatavetting <- TRUE
if (!is.null(opt$load_workspace)){
    if (!any((c("excel_metadata", "phenotable") %in% opt$replaced))) {
        opt$metadatavetting <- FALSE
    }
}

if (opt$metadatavetting == TRUE){
    #If phenolabels exists, make sure that phenotable contains only data described in phenolabels.
    if (exists("phenolabels")){
        if (!all(colnames(phenolabels) %in% c("Var_label", "Var_type"))) {
            stop("Could not find the Var_label and/or Var_type columns in phenolabels table. Consult documentation and check metadata file(s).")
        }

        validcols <- as.character(phenolabels$Var_label)
        flog.info(paste("Phenolabels contains", length(validcols), "categories."))

        #Stop if you are asking for more than you have.
        if(length(validcols) > ncol(phenotable)){
            stop("Phenolabels has more categories than the metadata in phenotable. Review and try again.")
        }

        ptsampcol <- as.character(phenolabels$Var_label[which(phenolabels$Var_type == "Sample")])
        if (length(ptsampcol) != 1){
             stop("You must define exactly one column as being the Sample column in your metadata. Please see documenation.")
        } else {
             flog.info(paste("Samples are in the", ptsampcol, "column in the metadata."))
        }

        flog.info(paste("Metadata classes specified in phenolabels are:", paste0(validcols, collapse=", ")))
        flog.info("Adjusting metadata to contain only these columns.")

        #Stop if the classes you want in phenolabels do not exist in phenotable.
        if(all(validcols %in% colnames(phenotable))){
            phenotable <- phenotable[ , validcols]
        } else {
            stop("One or more classes specified in phenolabels is missing as (a) column(s) in phenotable. Please check files.")
        }

    } else {
        #No phenolabels, so try and find at least a Sample column in the metadata.
        flog.info("Phenolabels not found. Will attempt to find which column is the Sample data.")
        ptsampcol <- colnames(phenotable)[which(colnames(phenotable) %in% c("Sample", "sample"))]
        if (length(ptsampcol) != 1){
            stop("You must define exactly one column as being the Sample column in your metadata. Please see documenation.")
        }
    }

    #Stop if something went wrong after subsetting phenotable to desired columns in phenolabels.
        if(nrow(phenotable) < 1){
        stop("No data found in the metadata file supplied. Please check file.")
    }
}

#Is there a list.data object? If not, make one.
Samples_want <- as.character(phenotable[ , ptsampcol])
if (!(exists("list.data"))) {
    #make a list.data object from jamsfiles
    flog.info(paste("Searching for .jams files in", opt$jamsfiles_path, sep = " "))
    flog.info("Loading all wanted .jams files into a single object.")
    if (length(Samples_want) > 200){
        flog.info("Crikey! There are over 200 samples to load. Go grab a coffee, this will take some time.")
    }
    list.data <- load_jamsfiles_from_system(path = opt$jamsfiles_path, onlysamples = Samples_want)
    #Save session
    flog.info("Saving R workspace image. Please be patient.")
    save.image(opt$projimage)
}

if (exists("Dupes")){
    list.data[grep(paste0(Dupes, "_"), names(list.data))] <- NULL
    list.data <- list.data[sapply(list.data, function(x){ !(is.null(x)) } )]
}

Samples_have <- name_samples(list.data = list.data)
Samples_missing <- Samples_want[!(Samples_want %in% Samples_have)]
if (length(Samples_missing) > 0){
    flog.warn(paste("The following samples in the metadata were not loaded, for lack of jamsfiles or otherwise. Check your metadata and jamsfiles path and restart if desired."))
    flog.warn(paste("MISSING:", paste0(Samples_missing, collapse = ", ")))
}

#If replacing metadata, check if they are the same samples.
if (exists("pheno")){
    if (any(c("excel_metadata", "phenotable") %in% opt$replaced)){
        #Readjust metadata for replacement
        adjustmetadata <- TRUE
    } else {
        #Keep metadata as is.
        adjustmetadata <- FALSE
    }
} else {
    #Adjust metadata for making experiments
    adjustmetadata <- TRUE
}

#Adjust metadata if required
if (adjustmetadata == TRUE){

    #See if there are reads data in list.data, and analyze reads if there is
    if (length(grep("_readstats", names(list.data))) > 0){
        flog.info("Found sequencing read assembly data in jams objects. Will incorporate read and assembly information.")
        doreads = TRUE
        # Set minimum number of Gb filter to 0 if not specified
        minGbNAHS <- as.numeric(opt$minGbNAHS)
        flog.info(paste("Will not include any sample with less than", minGbNAHS, "Gbp of usable data."))
        # Set minimum percentage assembly filter to 0 if not specified
        minPctAssembly <- as.numeric(opt$minPctAssembly)
        flog.info(paste("Will not include any sample with less than", minPctAssembly, "percent of reads assembled into contigs."))
    } else {
        flog.info("Sequencing read assembly data was not found in jams objects.")
        doreads <- FALSE
    }

    rownames(phenotable) <- phenotable$Sample
    phenotable <- phenotable[Samples_have, ]

    ## Evaluate reads, if required ##
    if(doreads == TRUE){
        flog.info("Evaluating sequencing.")
        readdata <- make_readdata(Samples = Samples_have, list.data = list.data)
        readplots <- plot_readdata(readdata = readdata)

        #Add sequencing info
        metadata2 <- adjust_phenotable(phenotable = phenotable, phenolabels = phenolabels, readdata = readdata, list.data = list.data, addtaxlevelstoisolates = c("Genus", "LKT"))
        pheno <- metadata2$phenotable
        phenolabels <- metadata2$phenolabels

        #Get rid of samples with not enough data
        pheno <- subset(pheno, GbNAHS >= minGbNAHS)
        pheno <- subset(pheno, PctAss >= minPctAssembly)

    } else {
        metadata2 <- adjust_phenotable(phenotable = phenotable, phenolabels = phenolabels, list.data = list.data, addtaxlevelstoisolates = c("Genus", "LKT"))
        pheno <- metadata2$phenotable
        phenolabels <- metadata2$phenolabels
    }

    #Define kinds of variables
    if (exists("phenolabels")){
        variable_list <- define_kinds_of_variables(phenolabels = phenolabels, phenotable = pheno, maxclass = maxclass, maxsubclass = 10)
        variables_disc <- variable_list$discrete
        variables_bin <- variable_list$binary
        variables_cont <- variable_list$continuous
        variables_subs <- variable_list$subsettable
    } else {
        variables_disc <- NULL
        variables_cont <- NULL
        variables_subs <- NULL
        variables_bin <- NULL
    }
    #Now that variables have been defined, plot original assembly and read status to pdf
    if (doreads == TRUE){
        assvecplot <- NULL
        if (length(variables_disc) > 0){
            assvecplot <- vector("list",length=length(variables_disc))
            for (p in 1:length(variables_disc)){
                assvecplot[[p]] <- plot_readscatter(readdata = readdata, phenotable = pheno, discrete = variables_disc[p])
            }
        }

        #Dump to pdf
        pdffn = paste("JAMS_Reads_Stats_", project, ".pdf", sep = "")
        pdf(pdffn, paper = "a4r")
        print(readplots)
        print(assvecplot)
        dev.off()
    }
}

#If there are no metagenomeSeq experiments, then build some.
if (!exists("expvec")){
    #Exclude samples in pheno table which have not been loaded in list.data
    flog.info(paste("Will build experiments for samples:", paste0(Samples_have, collapse = ", ")))

    #######################################
    ## Create Phyloseq and MGseq objects ##
    #######################################
    #Create a final phenotypic table to be used for metagenomeSeq experiments
    #Get sample list from current pheno
    Samples <- as.character(rownames(pheno))

    #Make MetagenomeSeq-style experiments
    flog.info("Making metagenomeSeq MRexperiment objects")
    expvec <- make_metagenomeSeq_experiments(pheno = pheno, list.data = list.data)

    flog.info("Saving R session image. Please be patient.")
    save.image(opt$projimage)
} else {
    #Expvec exists. Either do nothing, or replace the metadata.
    flog.info(paste("Found a list of metagenomeSeq experiments for the following analyses:", paste0(names(expvec), collapse = ", ")))
    #Check structure and integrity of experiments and see if they match the metadata.
    Samples_have <- rownames(pData(expvec[["LKT"]]))
    pheno <- pheno[Samples_have, ]
    #do this later
    #Replace metadata in expvec if required
    if (any(c("excel_metadata", "phenotable") %in% opt$replaced)) {
        if ("excel_metadata" %in% opt$replaced){
            mdXL <- opt$excel_metadata
            phenotableFN <- NULL
            phenolabelsFN <- NULL
        } else {
            mdXL <- NULL
            phenotableFN <- opt$phenotable
            phenolabelsFN <- opt$phenolabels
        }
        if (exists("readdata")){
            readdata2 <- readdata
        } else {
            readdata2 <- NULL
        }
        flog.info("Replacing metadata in current metagenomeSeq experiments.")
        expvec <- update_metadata(metadataXL = mdXL, phenotable = phenotableFN, phenolabels = phenolabelsFN, expvec = expvec, maxclass = maxclass, minGbNAHS = as.numeric(opt$minGbNAHS), minPctAssembly = as.numeric(opt$minPctAssembly), readdata = readdata2)
    }
}

###################
## Export tables ##
###################
if (opt$export_tables == TRUE){
    flog.info("Exporting count and feature tables.")
    tablespath <- paste(opt$outdir, "Tables", sep = "/")
    if (!(dir.exists(tablespath))){
        flog.info("Creating directory to hold tables.")
        dir.create(tablespath, showWarnings = FALSE, recursive = FALSE)
    }

    #Export current phenotable
    exporttabletsv(dataobj = pheno, project = project, basename = "Metadata", row.names = FALSE, col.names = TRUE, path = tablespath)

    analysesIhave <- names(expvec)
    for (analysis in analysesIhave){
        mgseqobj <- NULL
        mgseqobj <- expvec[[analysis]]
        mrc <- NULL
        mrc <- as.data.frame(MRcounts(mgseqobj))
        sampvec <- colnames(mrc)
        mrc$Feature <- rownames(mrc)
        mrc <- mrc[, c("Feature", sampvec)]
        exporttabletsv(dataobj = mrc, project = project, basename = paste(analysis, "NumBases", sep = "_"), row.names = FALSE, col.names = TRUE, path = tablespath)
        tt <- NULL
        tt <- as.data.frame(fData(mgseqobj))
        exporttabletsv(dataobj = tt, project = project, basename = paste(analysis, "FeatTable", sep = "_"), row.names = FALSE, col.names = TRUE, path = tablespath)
    }
    #Export as spreadsheet
    export_expvec_to_XL(expvec=expvec, filename=paste(paste(project, "counts", "PPM", sep="_"), "xlsx", sep="."))
}

########################################
## Make a colour dictionary for plots ##
########################################
flog.info("Making a dictionary of colours for consistency throughout plots.")
cdict <- make_colour_dictionary(variable_list = variable_list, pheno = pheno)

allexp <- names(expvec)
basicexp <- c("LKT", "ECNumber", "Product", "Pfam", "Interpro", "GO")[c("LKT", "ECNumber", "Product", "Pfam", "Interpro", "GO") %in% allexp]
specialexp <- c("vfdb", "resfinder", "antibiogram", "CDD", "PANTHER", "PRINTS", "SUPERFAMILY", "TIGRFAM")[c("vfdb", "resfinder", "antibiogram", "CDD", "PANTHER", "PRINTS", "SUPERFAMILY", "TIGRFAM") %in% allexp]

if ("isolate" %in% pheno$JAMS_Run_type){
    applyfilters = "none"
} else {
    applyfilters = "moderate"
}

#######################
## Do optional tasks ##
#######################

if (opt$ordination == TRUE){
    flog.info("Will now try to generate ordination plots based on Metadata which looks meaningful.")
    flog.info(paste0("Generating ordination plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
    tryCatch((make_ordination_report(project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", mgSeqnorm = FALSE, variable_list = variable_list, list.data = list.data, doreads = doreads, cdict = cdict)), error = function(e) whoopsieplot("generating ordination plots for basic analyses"))

    if (length(specialexp) > 0){
        flog.info(paste0("Generating ordination plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
        tryCatch((make_ordination_report(project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", mgSeqnorm = FALSE, variable_list = variable_list, list.data = list.data, doreads = doreads, cdict = cdict)), error = function(e) whoopsieplot("generating ordination plots for special analyses"))
    }
}

if (opt$make_exploratory_reports == TRUE){
    flog.info(paste0("Generating exploratory heatmap plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
    tryCatch((make_heatmap_report(report = "exploratory", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05)), error = function(e) whoopsieplot("generating exploratory heatmaps for basic analyses"))

    if (length(specialexp) > 0){
        flog.info(paste0("Generating exploratory heatmap plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "exploratory", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05)), error = function(e) whoopsieplot("generating exploratory heatmaps for special analyses"))
    }
}

if (opt$make_comparative_reports == TRUE){
    flog.info(paste0("Generating comparative heatmap plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
    tryCatch((make_heatmap_report(report = "comparative", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05)), error = function(e) whoopsieplot("generating comparative heatmaps for basic analyses"))

    if (length(specialexp) > 0){
        flog.info(paste0("Generating comparative heatmap plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "comparative", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05)), error = function(e) whoopsieplot("generating comparative heatmaps for special analyses"))
    }
}

if (opt$make_PA_reports == TRUE){
    if (length(variable_list$binary) > 0){
        flog.info(paste0("Generating presence/absence heatmap plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "PA", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05)), error = function(e) whoopsieplot("generating presence/absence heatmaps for basic analyses"))

        if (length(specialexp) > 0){
            flog.info(paste0("Generating presence/absence heatmap plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
            tryCatch((make_heatmap_report(report = "PA", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05)), error = function(e) whoopsieplot("generating presence/absence heatmaps for special analyses"))
        }
    } else {
        flog.info("There are no binary variables in the metadata supplied. PA testing can only be carried out with variables with exactly two classes.")
    }
}

if (opt$make_alpha_reports == TRUE){
    make_alpha_report(project = project, expvec = expvec, usefulexp = basicexp, variable_list = variable_list, cdict = cdict)
}

#Save image
flog.info("Saving R session image. Please be patient.")
save.image(opt$projimage)
