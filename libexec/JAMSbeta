#!/usr/bin/env Rscript
suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library(futile.logger))

#####################################
# Define System-specific Functions ##
#####################################
if ((.Platform$OS.type) != "unix"){
    stop("JAMS only works on UNIX. Install Linux and try again.")
}

#Get slurm job ID
slurmjobid <- as.character(Sys.getenv("SLURM_JOB_ID"))

#Decide which kind of system you are on.
if(nchar(slurmjobid) < 3){
    cat("You are not on a Slurm Workload Cluster\n")
} else {
    cat(paste("You are on a Slurm Workload Manager Cluster under jobID", slurmjobid, "\n"))
}

#################
## Get options ##
#################

option_list <- list(
    make_option(c("-p", "--projectname"),
                action="store", default = "MyProject",
                type="character",
                help="Name of project to be used as prefix for output files (required)"),

    make_option(c("-o", "--outdir"),
                action="store", default = getwd(),
                type="character",
                help ="path to where you want the output."),

    make_option(c("-x", "--excel_metadata"),
                action="store", default = NULL,
                type="character",
                help="Metadata file in Excel format, with sheet_1 for phenotable and sheet_2 for phenolabels"),

    make_option(c("-t", "--phenotable_tsv"),
                action="store", default = NULL,
                type="character",
                help="Metadata file in tsv format, with headers"),

    make_option(c("-l", "--phenolabels_tsv"),
                action="store", default = NULL,
                type="character",
                help="Phenolabels file in tsv format, describing metadata file headers"),

    make_option(c("-c", "--maxnumclasses"),
                action="store", default = 15,
                type="numeric",
                help="Maximum number of classes for a discrete variable to be kept. Default=10"),

    make_option(c("-i", "--class_to_ignore"),
                action="store", default = "N_A",
                type="character",
                help="Ignore cells containing this text in the metadata. Samples bearing this class of text when comparing within a variable will be omitted from an analysis."),

    make_option(c("-y", "--jamsfiles_path"),
                action="store", default = NULL,
                type="character",
                help ="path to where all .jams files are"),

    make_option(c("-w", "--load_workspace"),
                action="store", default = NULL,
                type="character",
                help ="/path/to/.RData  -  Continue or change the JAMSbeta pipeline from a previous workspace with an .RData file"),

    make_option(c("-g", "--minGbNAHS"),
                action="store", default = 0,
                type="numeric",
                help ="If using reads, what is the minimum amount of usable data, in Gbp, for a sample to be included in an experiment. (Default=0)"),

    make_option(c("-a", "--minPctAssembly"),
                action="store", default = 0,
                type="numeric",
                help ="If using reads, what is the minimum percentage assembly into contigs for a sample to be included in an experiment. (Default=0)"),

    make_option(c("-e", "--export_tables"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Export relative abundance tables and feature data tables in tsv format."),

    make_option(c("-d", "--make_ordination_reports"),
                action="store", default = NULL,
                type="character",
                help ="Generate ordination plots with this algorithm. Choose between PCA, tSNE or tUMAP, or more than one separated by a comma. Example: -d PCA,tUMAP"),

    make_option(c("-f", "--make_exploratory_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Relative Abundace heatmaps and spreadsheets based on variance analysis."),

    make_option(c("-k", "--make_comparative_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Relative Abundace heatmaps and spreadsheets for hypothesis testing using metadata categories."),

    make_option(c("-b", "--make_PA_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Relative Abundace heatmaps and spreadsheets for hypothesis testing using metadata categories."),

    make_option(c("-r", "--make_correlation_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate Pairwise Feature Correlation heatmaps."),

    make_option(c("-z", "--make_alpha_reports"),
                action="store_true", default = FALSE,
                type="logical",
                help ="Generate alpha diversity plots."),

    make_option(c("-s", "--run_script"),
                action="store", default = NULL,
                type="character",
                help ="Path to an R script to run after all other options have been executed. Example: -s /path/to/make_these_specific_plots.R will execute the commands in this script at the end of JAMSbeta."),

    make_option(c("-v", "--version"),
                action="store_true", help = "report version")
 )

# get the cmd line options to the script
args <- commandArgs(trailingOnly = TRUE)

# parse the options
opt <- parse_args(OptionParser(option_list = option_list), args)

#Add version from package to opt
opt$verstr <- paste0("JAMS v", packageVersion("JAMS"))

# print version & exit if -v
if (!is.null(opt$version)) {
    print(opt$verstr)
    quit()
}

#Fix path relativity
fixrelpath <- function(JAMSpath = NULL){
    require(R.utils)
    if(!(isAbsolutePath(JAMSpath))){
        fixedpath <- getAbsolutePath(JAMSpath)
    } else {
        fixedpath <- JAMSpath
    }

    return(fixedpath)
}

for (pathtofix in c("outdir", "excel_metadata", "phenotable_tsv", "phenolabels_tsv", "jamsfiles_path", "load_workspace", "run_script")){
    if (!is.null(opt[[pathtofix]])){
        opt[[pathtofix]] <- fixrelpath(opt[[pathtofix]])
    }
}

if (!is.null(opt$run_script)){
    #Check that file exists
    if (!file.exists(opt$run_script)){
        flog.info(paste("Unable to find file", opt$run_script))
        q()
    }
}

# Determine output directory
if (!is.null(opt$outdir)) {
    if (!file.exists(opt$outdir)){
        dir.create(opt$outdir, recursive = TRUE)
    }
    setwd(opt$outdir)
} else {
    opt$outdir <- getwd()
}
flog.info(paste("Content will be output to", opt$outdir))

# give help if needed input option not provided
if (all(c((is.null(opt$load_workspace)), (is.null(opt$jamsfiles_path))))) {
    parse_args(OptionParser(option_list = option_list), c("-h"))
    stop("You must supply .jams files with the -y option to build experiments. If you want to use a previous R session image, use --load_workspace")
} else {
    if (!is.null(opt$load_workspace)){
        flog.info("Attempting to continue from a previous JAMSbeta R session.")
        #Decide if workspace supplied is a folder or an image file itself.
        if(file.info(as.character(opt$load_workspace))$isdir == TRUE){
            opt$load_workspace <- file.path(opt$load_workspace, ".RData")
        }
        if (file.exists(opt$load_workspace)) {
            suppressMessages(suppressPackageStartupMessages(library(JAMS)))
            projimagesize <- file.size(opt$load_workspace)
            flog.info(paste("Found previous R session file with", projimagesize, "bytes at", as.character(opt$load_workspace)))
            saveRDS(opt, file = "preloadopt.rds") #Save current options, or else it will be substituted when loading workspace image.
            IO_jams_workspace_image(workspaceimage = opt$load_workspace, operation = "load")
            preloadopt <- readRDS("preloadopt.rds")
            #change name of ordination report option, for backwards compatibility. This patch will be phased out by July2020.
            if ("ordination" %in% names(opt)){
                names(opt)[which(names(opt) == "ordination")] <- "make_ordination_report"
            }
            rm(list=c("phenotable", "phenolabels")[c("phenotable", "phenolabels") %in% ls()])
            #Replace old options with new ones
            opt$replaced <- NULL
            optstosub <- names(preloadopt)[!(names(preloadopt) %in% c("jamsfiles_path", "load_workspace", "projimage", "projimagesize"))]
            optstoreset <- c("excel_metadata", "make_alpha_reports", "make_PA_reports", "make_comparative_reports", "make_exploratory_reports", "make_correlation_reports", "make_ordination_report", "export_tables")[(!(c("excel_metadata", "make_alpha_reports", "make_PA_reports", "make_comparative_reports", "make_exploratory_reports", "make_correlation_reports", "make_ordination_report", "export_tables") %in% opt$replaced))]
            for (resetopt in optstoreset){
                #flog.info(paste("Option", resetopt, "is set to FALSE."))
                opt[[resetopt]] <- FALSE
            }
            #Reset dupes
            opt$dupes <- NULL
            #May be missing in some old JAMS beta images
            if (is.null(opt[["outdir"]])){
                opt[["outdir"]] <- getwd()
            }
            missingopts <- optstosub[which(optstosub %in% names(opt) == FALSE)]
            for (missingopt in missingopts){
                opt[[missingopt]] <- FALSE
            }

            for (nametosub in optstosub){
                if (opt[[nametosub]] != preloadopt[[nametosub]]){
                    flog.info(paste0("For ", nametosub, ", ", opt[[nametosub]], " has been replaced with ", preloadopt[[nametosub]]))
                    opt[[nametosub]] <- preloadopt[[nametosub]]
                    opt$replaced <- append(opt$replaced, nametosub)
                }
            }
            file.remove("preloadopt.rds")

        } else {
            parse_args(OptionParser(option_list = option_list), c("-h"))
            stop("Unable to find a previous R session file in the output folder. If you want to build experiments from scratch, do not use the --continue (-u) option.")
        }
    }
}

#Set defaults
asPA <- FALSE
opt$projimage <- file.path(opt$outdir, ".RData")
###################
## Start project ##
###################
suppressMessages(suppressPackageStartupMessages(library(JAMS)))
flog.info("JAMSbeta start. Gathering information...")
project <- as.character(opt$projectname)
flog.info(paste("Using", project, "for name of project"))

opt$threads <- as.numeric(detectHardwareResources()["threads"])
flog.info(paste("You have", opt$threads, "CPUs available."))

##################
## Get metadata ##
##################

#keep metadata if it has changed from a previous version.
if (!is.null(opt$replaced)){
    if (!("excel_metadata" %in% opt$replaced)){
        opt$excel_metadata <- NULL
    }
    if (!("phenotable_tsv" %in% opt$replaced)){
        opt$phenotable_tsv <- NULL
        opt$phenolabels_tsv <- NULL
    }
}

#Get metadata
opt <- load_metadata_from_file(opt = opt)

#Stop if something went wrong
if ((is.null(opt$phenotable)) || (nrow(opt$phenotable) < 1)){
    stop("No data found in the metadata file supplied. Please check file.")
} else {
    flog.info(paste("Metadata has", ncol(opt$phenotable), "columns."))
}

##########
## Will keep this running in all cases. Not sure of the consequences for when loading a workspace and NOT changing metadata.
opt$metadatavetting <- TRUE
if (!is.null(opt$replaced)){
    if (!any((c("excel_metadata", "phenotable_tsv") %in% opt$replaced))) {
        opt$metadatavetting <- FALSE
    }
}

if (opt$metadatavetting == TRUE){
    #If phenolabels exists, make sure that phenotable contains only data described in phenolabels.
    if (!is.null(opt$phenolabels)){
        if (!all(colnames(opt$phenolabels) %in% c("Var_label", "Var_type"))) {
            stop("Could not find the Var_label and/or Var_type columns in phenolabels table. Consult documentation and check metadata file(s).")
        }

        validcols <- as.character(opt$phenolabels$Var_label)
        flog.info(paste("Phenolabels contains", length(validcols), "categories."))

        #Stop if you are asking for more than you have.
        if (length(validcols) > ncol(opt$phenotable)){
            stop("Phenolabels has more categories than the metadata in phenotable. Review and try again.")
        }

        ptsampcol <- as.character(opt$phenolabels$Var_label[which(opt$phenolabels$Var_type == "Sample")])
        if (length(ptsampcol) != 1){
             stop("You must define exactly one column as being the Sample column in your metadata. Please see documenation.")
        } else {
             flog.info(paste("Samples are in the", ptsampcol, "column in the metadata."))
        }

        flog.info(paste("Metadata classes specified in phenolabels are:", paste0(validcols, collapse = ", ")))
        flog.info("Adjusting metadata to contain only these columns.")

        #Stop if the classes you want in phenolabels do not exist in phenotable.
        if (all(validcols %in% colnames(opt$phenotable))){
            opt$phenotable <- opt$phenotable[ , validcols]
        } else {
            stop("One or more classes specified in phenolabels is missing as (a) column(s) in phenotable. Please check files.")
        }

    } else {
        #No phenolabels, so try and find at least a Sample column in the metadata.
        flog.info("Phenolabels not found. Will attempt to find which column is the Sample data.")
        ptsampcol <- colnames(opt$phenotable)[which(colnames(opt$phenotable) %in% c("Sample", "sample"))]
        if (length(ptsampcol) != 1){
            stop("You must define exactly one column as being the Sample column in your metadata. Please see documenation.")
        }
    }

    #Stop if something went wrong after subsetting phenotable to desired columns in phenolabels.
        if(nrow(opt$phenotable) < 1){
        stop("No data found in the metadata file supplied. Please check file.")
    }
}

#Is there a list.data object? If not, make one.
Samples_want <- as.character(opt$phenotable[ , ptsampcol])
if (!(exists("list.data"))) {
    #make a list.data object from jamsfiles
    flog.info(paste("Searching for .jams files in", opt$jamsfiles_path, sep = " "))
    flog.info("Loading all wanted .jams files into a single object.")
    if (length(Samples_want) > 200){
        flog.info("Crikey! There are over 200 samples to load. Go grab a coffee, this will take some time.")
    }
    list.data <- load_jamsfiles_from_system(path = opt$jamsfiles_path, onlysamples = Samples_want, threads = opt$threads)
    #Save session
    IO_jams_workspace_image(opt = opt, operation = "save")
}
if (length(opt$dupes) > 0){
    list.data[grep(paste0(opt$dupes, "_"), names(list.data))] <- NULL
    list.data <- list.data[sapply(list.data, function(x){ !(is.null(x)) } )]
}

Samples_have <- name_samples(list.data = list.data)
Samples_missing <- Samples_want[!(Samples_want %in% Samples_have)]
if (length(Samples_missing) > 0){
    flog.warn(paste("The following samples in the metadata were not loaded, for lack of jamsfiles or otherwise. Check your metadata and jamsfiles path and restart if desired."))
    flog.warn(paste("MISSING:", paste0(Samples_missing, collapse = ", ")))
}

#If replacing metadata, check if they are the same samples.
if (exists("pheno")){
    if (any(c("excel_metadata", "phenotable_tsv") %in% opt$replaced)){
        #Readjust metadata for replacement
        adjustmetadata <- TRUE
    } else {
        #Keep metadata as is.
        adjustmetadata <- FALSE
    }
} else {
    #Adjust metadata for making experiments
    adjustmetadata <- TRUE
}

#Adjust metadata if required
if (adjustmetadata == TRUE){

    #See if there are reads data in list.data, and analyze reads if there is
    if (length(grep("_readstats", names(list.data))) > 0){
        flog.info("Found sequencing read assembly data in jams objects. Will incorporate read and assembly information.")
        opt$doreads = TRUE
        # Set minimum number of Gb filter to 0 if not specified
        flog.info(paste("Will not include any sample with less than", opt$minGbNAHS, "Gbp of usable data."))
        # Set minimum percentage assembly filter to 0 if not specified
        flog.info(paste("Will not include any sample with less than", opt$minPctAssembly, "percent of reads assembled into contigs."))
    } else {
        flog.info("Sequencing read assembly data was not found in jams objects.")
        opt$doreads <- FALSE
    }

    rownames(opt$phenotable) <- opt$phenotable$Sample
    opt$phenotable <- opt$phenotable[(rownames(opt$phenotable)[rownames(opt$phenotable) %in% Samples_have]), ]

    ## Evaluate reads, if required ##
    if (opt$doreads == TRUE){
        flog.info("Evaluating sequencing.")
        opt$readdata <- make_readdata(Samples = Samples_have, list.data = list.data)
        opt$readplots <- plot_readdata(readdata = opt$readdata)
    }

    #Adjust phenotable
    opt <- adjust_phenotable(opt = opt, list.data = list.data, addtaxlevelstoisolates = c("Genus", "LKT"), class_to_ignore = opt$class_to_ignore)

    #Get rid of samples with not enough data
    opt$phenotable <- subset(opt$phenotable, GbNAHS >= opt$minGbNAHS)
    opt$phenotable <- subset(opt$phenotable, PctAss >= opt$minPctAssembly)

    #Define kinds of variables
    variable_list <- define_kinds_of_variables(phenolabels = opt$phenolabels, phenotable = opt$phenotable, maxclass = opt$maxnumclasses, maxsubclass = 6, class_to_ignore = opt$class_to_ignore)

    #Now that variables have been defined, plot original assembly and read status to pdf
    if (opt$doreads == TRUE){
        if (length(variable_list$discrete) > 0){
            opt$assvecplot <- plot_readscatter(opt = opt)
        }

        #Dump to pdf
        pdffn = paste("JAMS_Reads_Stats_", opt$projectname, ".pdf", sep = "")
        pdf(pdffn, paper = "a4r")
        quiet(print(opt$readplots))
        quiet(print(opt$assvecplot))
        dev.off()
    }
}

pheno <- opt$phenotable
phenolabels <- opt$phenolabels

#If there are no metagenomeSeq experiments, then build some.
if (!exists("expvec")){
    #Exclude samples in pheno table which have not been loaded in list.data
    flog.info(paste("Will build experiments for samples:", paste0(Samples_have, collapse = ", ")))

    #######################################
    ## Create Phyloseq and MGseq objects ##
    #######################################
    #Get sample list from current pheno
    Samples <- as.character(rownames(pheno))

    #Make MetagenomeSeq-style experiments
    flog.info("Making metagenomeSeq MRexperiment objects")
    expvec <- make_metagenomeSeq_experiments(pheno = pheno, list.data = list.data)

    IO_jams_workspace_image(opt = opt, operation = "save")

} else {
    #Expvec exists. Either do nothing, or replace the metadata.
    flog.info(paste("Found a list of metagenomeSeq experiments for the following analyses:", paste0(names(expvec), collapse = ", ")))
    #Check structure and integrity of experiments and see if they match the metadata.
    Samples_have <- rownames(pData(expvec[["LKT"]]))
    pheno <- pheno[(rownames(pheno)[rownames(pheno) %in% Samples_have]), ]

    #Replace metadata in expvec if required
    if (any(c("excel_metadata", "phenotable_tsv") %in% opt$replaced)) {
        flog.info("Replacing metadata in current metagenomeSeq experiments.")

        for (e in 1:length(expvec)){
            analysis <- names(expvec)[e]
            oldmetadata <- pData(expvec[[e]])
            wantedsamples <- rownames(pheno)
            #If there is discrepancy between exising metadata in expvec and metadata available, use intersection
            Samples_intersect <- intersect(oldmetadata[, ptsampcol], wantedsamples)
            pheno2 <- pheno[Samples_intersect, ]
            cts2 <- MRcounts(expvec[[e]])
            cts2 <- cts2[ , Samples_intersect]
            #Protect against rows with empty data
            rowsToKeep <- names(which(rowSums(cts2) > 0 & rownames(cts2) != ""))
            cts2 <- cts2[rowsToKeep, ]
            ft2 <- fData(expvec[[e]])
            ft2 <- ft2[rowsToKeep, ]

            ##Create metagenomeSeq MRexperiment
            phenotypeData <- AnnotatedDataFrame(pheno2)
            ttdata <- AnnotatedDataFrame(ft2)
            mgseq <- newMRexperiment(cts2, phenoData = phenotypeData, featureData = ttdata)
            attr(mgseq, "analysis") <- analysis
            expvec[[e]] <- mgseq
        }
    } #End conditional for replacing metadata
}

###################
## Export tables ##
###################
if (opt$export_tables == TRUE){
    flog.info("Exporting count and feature tables.")
    tablespath <- file.path(opt$outdir, "Tables")
    if (!(dir.exists(tablespath))){
        flog.info("Creating directory to hold tables.")
        dir.create(tablespath, showWarnings = FALSE, recursive = FALSE)
    }

    #Export current phenotable
    exporttabletsv(dataobj = pheno, project = opt$projectname, basename = "Metadata", row.names = FALSE, col.names = TRUE, path = tablespath)

    analysesIhave <- names(expvec)
    for (analysis in analysesIhave){
        mgseqobj <- NULL
        mgseqobj <- expvec[[analysis]]
        mrc <- NULL
        mrc <- as.data.frame(MRcounts(mgseqobj))
        sampvec <- colnames(mrc)
        mrc$Feature <- rownames(mrc)
        mrc <- mrc[, c("Feature", sampvec)]
        exporttabletsv(dataobj = mrc, project = opt$projectname, basename = paste(analysis, "NumBases", sep = "_"), row.names = FALSE, col.names = TRUE, path = tablespath)
        tt <- NULL
        tt <- as.data.frame(fData(mgseqobj))
        exporttabletsv(dataobj = tt, project = opt$projectname, basename = paste(analysis, "FeatTable", sep = "_"), row.names = FALSE, col.names = TRUE, path = tablespath)
    }
    #Export as spreadsheet
    export_expvec_to_XL(expvec = expvec, filename = paste(paste(project, "counts", "PPM", sep = "_"), "xlsx", sep = "."))
}

########################################
## Make a colour dictionary for plots ##
########################################
flog.info("Making a dictionary of colours for consistency throughout plots.")
cdict <- make_colour_dictionary(variable_list = variable_list, pheno = pheno, class_to_ignore = opt$class_to_ignore, shuffle = FALSE)

allexp <- names(expvec)
basicexp <- c("LKT", "ECNumber", "Product", "Pfam", "Interpro", "GO")[c("LKT", "ECNumber", "Product", "Pfam", "Interpro", "GO") %in% allexp]
specialexp <- c("vfdb", "resfinder", "antibiogram", "CDD", "PANTHER", "PRINTS", "SUPERFAMILY", "TIGRFAM")[c("vfdb", "resfinder", "antibiogram", "CDD", "PANTHER", "PRINTS", "SUPERFAMILY", "TIGRFAM") %in% allexp]

if ("isolate" %in% pheno$JAMS_Run_type){
    applyfilters <- "none"
} else {
    applyfilters <- "moderate"
}

#######################
## Do optional tasks ##
#######################

if (!is.null(opt$make_ordination_reports)){
    flog.info(paste("Will now try to generate ordination plots based on Metadata which looks meaningful using", opt$make_ordination_reports))
    #Get algorithms requested
    ordalgs <- unlist(strsplit(opt$make_ordination_reports, split = ","))
    #Make an ordination plot report for each algorithm
    for (ordalg in ordalgs){
        flog.info(paste0("Generating ordination plots with ", ordalg, " for basic analyses (", paste(basicexp, collapse= ", "), ")."))
        tryCatch((make_ordination_report(algorithm = ordalg, project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = paste("Basic", ordalg, sep = "_"), mgSeqnorm = FALSE, variable_list = variable_list, list.data = list.data, doreads = opt$doreads, cdict = cdict, threads = opt$threads, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating ordination plots for basic analyses"))

        if (length(specialexp) > 0){
            flog.info(paste0("Generating ordination plots with ", ordalg, " for special analyses (", paste(specialexp, collapse= ", "), ")."))
            tryCatch((make_ordination_report(algorithm = ordalg, project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = paste("Special", ordalg, sep = "_"), mgSeqnorm = FALSE, variable_list = variable_list, list.data = list.data, doreads = opt$doreads, cdict = cdict, threads = opt$threads, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating ordination plots for special analyses"))
        }
    }
}

if (opt$make_exploratory_reports == TRUE){
    flog.info(paste0("Generating exploratory heatmap plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
    tryCatch((make_heatmap_report(report = "exploratory", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 2, numthreads = opt$threads, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating exploratory heatmaps for basic analyses"))

    if (length(specialexp) > 0){
        flog.info(paste0("Generating exploratory heatmap plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "exploratory", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating exploratory heatmaps for special analyses"))
    }
}

if (opt$make_comparative_reports == TRUE){
    flog.info(paste0("Generating comparative heatmap plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
    tryCatch((make_heatmap_report(report = "comparative", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating comparative heatmaps for basic analyses"))

    if (length(specialexp) > 0){
        flog.info(paste0("Generating comparative heatmap plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "comparative", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating comparative heatmaps for special analyses"))
    }
}

if (opt$make_PA_reports == TRUE){
    if (length(variable_list$binary) > 0){
        flog.info(paste0("Generating presence/absence heatmap plots for basic analyses (", paste(basicexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "PA", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating presence/absence heatmaps for basic analyses"))

        if (length(specialexp) > 0){
            flog.info(paste0("Generating presence/absence heatmap plots for special analyses (", paste(specialexp, collapse= ", "), ")."))
            tryCatch((make_heatmap_report(report = "PA", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", showonlypbelow = 0.05, class_to_ignore = opt$class_to_ignore)), error = function(e) whoopsieplot("generating presence/absence heatmaps for special analyses"))
        }
    } else {
        flog.info("There are no binary variables in the metadata supplied. PA testing can only be carried out with variables with exactly two classes.")
    }
}

if (opt$make_correlation_reports == TRUE){
    flog.info(paste0("Generating feature correlation heatmaps for basic analyses (", paste(basicexp, collapse= ", "), ")."))
    tryCatch((make_heatmap_report(report = "correlation", project = project, expvec = expvec, usefulexp = basicexp, appendtofilename = "Basic", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", minabscorrcoeff = 0.55, ntopvar = 250)), error = function(e) whoopsieplot("generating comparative heatmaps for basic analyses"))

    if (length(specialexp) > 0){
        flog.info(paste0("Generating feature correlation heatmaps for special analyses (", paste(specialexp, collapse= ", "), ")."))
        tryCatch((make_heatmap_report(report = "correlation", project = project, expvec = expvec, usefulexp = specialexp, appendtofilename = "Special", applyfilters = applyfilters, variable_list = variable_list, list.data = list.data, mgSeqnorm = FALSE, cdict = cdict, makespreadsheets = TRUE, makeheatmaps = TRUE, maxnumheatmaps = 3, numthreads = opt$threads, adjustpval = "auto", minabscorrcoeff = 0.55, ntopvar = 250)), error = function(e) whoopsieplot("generating comparative heatmaps for special analyses"))
    }
}

if (opt$make_alpha_reports == TRUE){
    make_alpha_report(project = project, expvec = expvec, usefulexp = basicexp, variable_list = variable_list, cdict = cdict)
}

#Save image
IO_jams_workspace_image(opt = opt, operation = "save")

#Running extra script if required
if (!is.null(opt$run_script)){
    flog.warn(paste("The contents of file", opt$run_script, "will now be run on this session."))
    source(opt$run_script)
}
